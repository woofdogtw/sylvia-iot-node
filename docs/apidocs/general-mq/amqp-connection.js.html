<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: amqp-connection.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: amqp-connection.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

const { EventEmitter } = require('events');
const { URL } = require('url');

const amqplib = require('amqplib/callback_api');

const { DataTypes, Events, Status } = require('./constants');

const DEF_URI = 'amqp://localhost';
const DEF_CONN_TIMEOUT = 3000;
const DEF_RECONN = 1000;

/**
 * Connection error event.
 *
 * @event AmqpConnection#error
 * @type {Error}
 */

/**
 * Connection status event.
 *
 * @event AmqpConnection#status
 * @type {Status}
 */

/**
 * Manages an AMQP connection.
 *
 * @class AmqpConnection
 * @fires AmqpConnection#error
 * @fires AmqpConnection#status
 */
class AmqpConnection extends EventEmitter {
  /**
   * @constructor
   * @param {Object} [opts] The connection options.
   *   @param {string} [opts.uri='amqp://localhost'] Connection URI. Use
   *          `amqp|amqps://username:password@host:port/vhost` format.
   *   @param {number} [opts.connectTimeoutMillis=3000] Connection timeout in milliseconds.
   *   @param {number} [opts.reconnectMillis=1000] Time in milliseconds from disconnection to
   *          reconnection.
   *   @param {boolean} [opts.insecure=false] Allow insecure TLS connection.
   * @throws {Error} Wrong arguments.
   */
  constructor(opts) {
    super();

    if (opts === undefined) {
      opts = {};
    } else {
      if (!opts || typeof opts !== DataTypes.Object || Array.isArray(opts)) {
        throw Error('`opts` is not an object');
      }
      if (opts.uri !== undefined) {
        if (!opts.uri || typeof opts.uri !== DataTypes.String) {
          throw Error('`uri` is not a string');
        } else if (!URL.canParse(opts.uri)) {
          throw Error('`uri` is not a valid URI');
        }
        const u = new URL(opts.uri);
        if (u.protocol !== 'amqp:' &amp;&amp; u.protocol !== 'amqps:') {
          throw Error('`uri` scheme only support `amqp` and `amqps`');
        }
      }
      if (
        opts.connectTimeoutMillis !== undefined &amp;&amp;
        (!Number.isInteger(opts.connectTimeoutMillis) || opts.connectTimeoutMillis &lt; 0)
      ) {
        throw Error('`connectTimeoutMillis` is not a positive integer');
      } else if (
        opts.reconnectMillis !== undefined &amp;&amp;
        (!Number.isInteger(opts.reconnectMillis) || opts.reconnectMillis &lt; 0)
      ) {
        throw Error('`reconnectMillis` is not a positive integer');
      } else if (opts.insecure !== undefined &amp;&amp; typeof opts.insecure !== DataTypes.Boolean) {
        throw Error('`insecure` is not a boolean');
      }
    }

    this.#opts = {
      uri: opts.uri || DEF_URI,
      connectTimeoutMillis: opts.connectTimeoutMillis || DEF_CONN_TIMEOUT,
      reconnectMillis: opts.reconnectMillis || DEF_RECONN,
      insecure: opts.insecure || false,
    };
    this.#status = Status.Closed;
    this.#conn = null;
  }

  /**
   * To get the connection status.
   *
   * @returns {Status}
   */
  status() {
    return this.#status;
  }

  /**
   * To connect to the message broker. The `AmqpConnection` will report status with Status.
   */
  connect() {
    if (this.#status !== Status.Closed &amp;&amp; this.#status !== Status.Closing) {
      return;
    }

    this.#status = Status.Connecting;
    this.emit(Events.Status, Status.Connecting);

    this.#innerConnect();
  }

  /**
   * To close the connection. You can use a callback function to get the result or listen events.
   *
   * @param {function} [callback]
   *   @param {?Error} callback.err
   */
  close(callback) {
    if (typeof callback !== DataTypes.Function) {
      callback = null;
    }

    if (!this.#conn) {
      if (callback) {
        return void process.nextTick(() => {
          callback(null);
        });
      }
      return;
    }

    this.#status = Status.Closing;
    this.emit(Events.Status, Status.Closing);
    const self = this;
    this.#conn.close((err) => {
      if (self.#conn) {
        self.#conn.removeAllListeners();
        self.#conn = null;
      }
      self.#status = Status.Closed;
      self.emit(Events.Status, Status.Closed);
      if (callback) {
        return void process.nextTick(() => {
          callback(err);
        });
      }
    });
  }

  /**
   * To get the raw AMQP connection instance for channel declaration.
   *
   * @private
   * @returns {?amqplib.Connection} The connection instance.
   */
  getRawConnection() {
    return this.#conn;
  }

  #innerConnect() {
    let self = this;
    const opts = {};
    if (this.#opts.insecure) {
      opts.rejectUnauthorized = false;
    }
    amqplib.connect(this.#opts.uri, opts, (err, conn) => {
      if (err) {
        return void setTimeout(() => {
          self.#innerConnect();
        }, self.#opts.reconnectMillis);
      }

      conn.on('close', self.#onClose.bind(self));
      conn.on('error', self.#onError.bind(self));
      self.#conn = conn;
      self.#status = Status.Connected;
      self.emit(Events.Status, Status.Connected);
    });
  }

  #onClose() {
    if (this.#conn) {
      this.#conn.removeAllListeners();
      this.#conn = null;
    }

    if (this.#status !== Status.Closing &amp;&amp; this.#status !== Status.Closed) {
      this.#status = Status.Connecting;
      this.emit(Events.Status, Status.Connecting);
      this.#innerConnect();
    }
  }

  #onError(err) {
    if (this.#status !== Status.Closed) {
      this.emit(Events.Error, err);
    }
  }

  #opts;
  /** @type {Status} */
  #status;
  /** @type {amqplib.Connection} */
  #conn;
}

module.exports = {
  AmqpConnection,
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AmqpConnection.html">AmqpConnection</a></li><li><a href="AmqpQueue.html">AmqpQueue</a></li><li><a href="MqttConnection.html">MqttConnection</a></li><li><a href="MqttQueue.html">MqttQueue</a></li></ul><h3>Events</h3><ul><li><a href="AmqpConnection.html#event:error">error</a></li><li><a href="AmqpConnection.html#event:status">status</a></li><li><a href="AmqpQueue.html#event:error">error</a></li><li><a href="AmqpQueue.html#event:status">status</a></li><li><a href="MqttConnection.html#event:error">error</a></li><li><a href="MqttConnection.html#event:status">status</a></li><li><a href="MqttQueue.html#event:error">error</a></li><li><a href="MqttQueue.html#event:status">status</a></li></ul><h3>Global</h3><ul><li><a href="global.html#DataTypes">DataTypes</a></li><li><a href="global.html#Errors">Errors</a></li><li><a href="global.html#Events">Events</a></li><li><a href="global.html#Status">Status</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sat Aug 26 2023 17:16:10 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
